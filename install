#!/usr/bin/env python3

from __future__ import annotations
from argparse import ArgumentParser
from subprocess import run
from typing import Any, Callable, Dict, Iterable, List, Tuple, Type, Union
import pathlib
import shutil
from yaml.cyaml import CLoader as Loader
import os
import yaml


HOME = os.getenv('HOME')
assert HOME is not None


KeyWord = str
Target = str
Path = str


def load_config(dir: str, file_name='dotfiles.yaml'
        ) -> Dict[Target, List[Dict[KeyWord, Any]]]:
    # load config
    config: Dict
    path = os.path.join(dir, file_name)
    with open(path, 'r') as fh:
        config = yaml.load(fh.read(), Loader=Loader)

    # check validity
    def is_ordered_map(entry) -> bool:
        return (isinstance(entry, List)
                and all(map(lambda i:
                    isinstance(i, dict) and len(i) == 1, entry)))
    for key, value in config.items():
        if not is_ordered_map(value):
            raise Exception(f"Malformed config for target '{key}'.")
    return config


class Environment:
    dotfile_installer: DotfileInstaller
    current_target: Target
    def __init__(self, dotfile_installer, target):
        self.dotfile_installer = dotfile_installer
        self.current_target = target


class Action:
    job: Callable[[], Any]
    desc: str
    env: Environment

    def set_job(self, job: Callable[[], Any], desc: str):
        self.job = job
        self.desc = desc

    def set_env(self, env: Environment):
        self.env = env

    def get_description(self) -> str:
        return self.desc

    def execute(self) -> None:
        self.job()


class Plugin:
    def set_env(self, env: Environment):
        self.env = env

    def parse_config(self, _) -> List[Action]:
        raise Exception()


PluginConstructor = Type[Plugin]
PLUGINS: Dict[KeyWord, PluginConstructor] = {}


def register_plugin(key_word):
    def inner(cl):
        PLUGINS[key_word] = cl
        return cl
    return inner


def get_plugins():
    return PLUGINS


def validate(validator: Union[type, Callable], iter: Iterable):
    for el in iter:
        if isinstance(validator, type):
            assert isinstance(el, validator), f"Invalid item{el}"
        elif isinstance(validator, Callable):
            assert validator(el), f"Invalid item{el}"
        yield el


def islistof(ls: List, type: Type) -> bool:
    return any(map(lambda el: isinstance(el, type), ls))


def create_symlink(src: Path, dst):
    if not os.path.exists(src):
        print(f"Link source {src} does not exist. Skipping...")
        return

    if os.path.islink(dst):  # bad symlinks don't "exist"
        os.unlink(dst)
    elif os.path.exists(dst):
        was_deleted = ask_and_delete(dst)
        if not was_deleted:
            return
    pathlib.Path(os.path.dirname(dst)).mkdir(parents=True, exist_ok=True)
    os.symlink(src, dst)


def expand_path(path: str, default_prefix: str) -> str:
    if path.startswith('/'):
        return path
    elif path.startswith('~'):
        return os.path.join(HOME, path[1:])
    else:
        return os.path.join(default_prefix, path)


def ask_and_delete(path: str) -> bool:
    while True:
        print(f"The file/directory '{path}' already exists.")
        print("Do you want to remove it? [y/N]")
        answer = input()
        if answer in ['y', 'Y']:
            delete_file_or_dir(path)
            return True
        elif answer in ['', 'n', 'N']:
            return False


def delete_file_or_dir(path: str):
    if os.path.isfile(path):
        os.remove(path)
    elif os.path.isdir(path):
        shutil.rmtree(path)



###########
# Plugins #
###########


@register_plugin('profile')
class ProfilePlugin(Plugin):
    key_word = 'profile'
    def parse_config(self, config) -> Iterable[Action]:
        dotfiles_dir = self.env.dotfile_installer.dotfiles_dir

        def create_action(name: str):
            file_name = name + '.sh'
            src = os.path.join(dotfiles_dir, 'profile.d', file_name)
            dst = os.path.join(HOME, '.profile.d/', file_name) # type: ignore
            return CreateSymlink(src, dst)

        if isinstance(config, str):
            yield create_action(config)
        else:
            return map(create_action, validate(str, config))


@register_plugin('flavours')
class FlavoursPlugin(Plugin):
    def parse_config(self, config) -> Iterable[Action]:
        dotfiles_dir = self.env.dotfile_installer.dotfiles_dir

        def create_action(name: str):
            file_name = name + '.toml'
            src = os.path.join(dotfiles_dir, 'flavours.d', file_name)
            dst = os.path.join(HOME, '.config/flavours/config.toml.d', file_name) # type: ignore
            return CreateSymlink(src, dst)

        if isinstance(config, str):
            yield create_action(config)
        else:
            return map(create_action, validate(str, config))



@register_plugin('hooks')
class HooksPlugin(Plugin):
    def parse_config(self, config) -> Iterable[Action]:
        dotfiles_dir = self.env.dotfile_installer.dotfiles_dir
        hooks_dir = os.path.join(dotfiles_dir, 'hooks')
        exp = lambda f: expand_path(f, hooks_dir)
        return map(RunCmd, map(exp, validate(str, config)))


@register_plugin('links')
class LinksPlugin(Plugin):
    def parse_config(self, config) -> Iterable[Action]:
        dotfiles_dir = self.env.dotfile_installer.dotfiles_dir
        is_valid = lambda i: isinstance(i[0], str) and isinstance(i[1], str)
        for src, dst in validate(is_valid, config.items()):
            src = expand_path(src, dotfiles_dir)
            dst = expand_path(dst, HOME) # type: ignore
            yield CreateSymlink(src, dst)


@register_plugin('needs')
class NeedsPlugin(Plugin):
    def parse_config(self, config) -> Iterable[Action]:
        for target in validate(str, config):
            self.env.dotfile_installer.add(target)
        return
        yield


@register_plugin('run')
class RunPlugin(Plugin):
    def parse_config(self, config) -> Iterable[Action]:
        is_valid = lambda cmd: isinstance(cmd, str) or islistof(cmd, str)
        return map(RunCmd, validate(is_valid, config))


@register_plugin('system-install')
class SystemInstallPlugin(Plugin):
    def parse_config(self, config) -> Iterable[Action]:
        dotfiles_dir = self.env.dotfile_installer.dotfiles_dir
        exp = lambda f: expand_path(f, dotfiles_dir)
        for file in map(exp, validate(str, config)):
            if os.path.isfile(file):
                yield SystemInstallFile(file)
            elif os.path.isdir(file):
                yield SudoMakeInstall(file)
            else:
                raise Exception(f'{file} is neither file nor directory')


@register_plugin('install')
class InstallPlugin(Plugin):
    def parse_config(self, config) -> Iterable[Action]:
        dotfiles_dir = self.env.dotfile_installer.dotfiles_dir
        exp = lambda f: expand_path(f, dotfiles_dir)
        for path in map(exp, validate(str, config)):
            if os.path.isfile(path):
                yield InstallFile(path)
            elif os.path.isdir(path):
                yield MakeInstall(path)
            else:
                raise Exception(f'{path} is neither file nor directory')



###########
# Actions #
###########


class PrintMsg(Action):
    def __init__(self, msg: str):
        self.set_job(lambda: None, msg)


class CreateSymlink(Action):
    def __init__(self, src: Path, dst: Path):
        desc = f"Creating symlink {src} -> {dst}"
        job = lambda: create_symlink(src, dst)
        self.set_job(job, desc)


class SudoMakeInstall(Action):
    def __init__(self, dir: str):
        desc = f'Running `sudo make install` inside {dir}'
        job = lambda: run(['sudo', 'make', 'install'], cwd=dir)
        self.set_job(job, desc)


class MakeInstall(Action):
    def __init__(self, dir: str):
        self.dir = dir
        desc = f'Running `make install` inside {self.dir}'
        job = lambda: run(['make', 'install'], cwd=self.dir)
        self.set_job(job, desc)


class InstallTarget(Action):
    def __init__(self, target: str):
        desc = f"Installing target '{target}'"
        job = lambda: self.env.dotfile_installer.add(target)
        self.set_job(job, desc)


class RunCmd(Action):
    def __init__(self, cmd: Union[str, List[str]]):
        s = f"{' '.join(cmd)}" if isinstance(cmd, list) else f'bash -c "{cmd}"'
        desc = f"Running '{s}'"
        cmd = cmd if isinstance(cmd, list) else ['bash', '-c', cmd]
        job = lambda: run(cmd, cwd=self.env.dotfile_installer.dotfiles_dir)
        self.set_job(job, desc)


class SystemInstallFile(RunCmd):
    def __init__(self, file: str):
        cmd = ['sudo', 'install', '-m755', '/usr/bin/', file]
        RunCmd.__init__(self, cmd)


class InstallFile(RunCmd):
    def __init__(self, file: str):
        cmd = ['install', '-m755', '-D', f'-t={HOME}/.local/bin', file]
        RunCmd.__init__(self, cmd)



class DotfileInstaller:
    dotfiles_dir: Path
    config_by_target: Dict[Target, List[Dict[KeyWord, Any]]]
    dry_run: bool
    _installed: List[Target] = []
    _actions: List[Action] = []

    def __init__(self, dotfiles_dir: Path, dry_run=False):
        self.dotfiles_dir = dotfiles_dir
        self.config_by_target = load_config(dotfiles_dir)
        self.dry_run = dry_run

    def install(self, targets: List[Target]):
        for target in targets:
            self.add(target)
        self.execute_actions()

    def check(self):
        for target in self.config_by_target.keys():
            self.add(target)

    def add(self, target: Target):
        if target in self._installed:
            return
        self._installed.append(target)
        self._actions.append(PrintMsg(f"Installing target {target}"))

        env = Environment(self, target)
        for key_word, config in self.get_config(target):
            plugin = self.get_plugin(key_word)
            plugin.set_env(env)
            for action in plugin.parse_config(config):
                action.set_env(env)
                self._actions.append(action)
        self._actions.append(PrintMsg(f"Finished installation of target {target}"))

    def execute_actions(self):
        for action in self._actions:
            print(action.get_description())
            if not self.dry_run:
                action.execute()

    def get_config(self, target: Target) -> Iterable[Tuple[KeyWord, Any]]:
        try:
            config = self.config_by_target[target]
        except KeyError:
            self.abort(f"No config found for target '{target}'")
        for item in config:
            for key, value in item.items():
                yield (key, value)

    def get_plugin(self, key_word: KeyWord):
        plugins = get_plugins()
        try:
            return plugins[key_word]()
        except KeyError:
            self.abort(f"no plugin for keyword '{key_word}'")

    def list_targets(self):
        print('Available targets:')
        print('==================')
        for target in self.config_by_target.keys():
            print(target)

    def print_success(self):
        print()
        print("Successfully installed the following targets:")
        print("=============================================")
        for target in self._installed:
            print(target)
        exit(0)

    def abort(self, msg):
        print(f"ERROR: {msg}")
        exit(1)



def parse_args():
    parser = ArgumentParser()
    parser.add_argument('install_targets', metavar='TARGET', type=str, nargs='*',
                        help='targets to install')
    parser.add_argument('--dry-run', '-d', action='store_true', default=False,
                        help='only print what would be done')
    parser.add_argument('--list', '-l', action='store_true',
                        help='list all install targets')
    parser.add_argument('--check', '-c', action='store_true',
                        help='check config and print the first error encountered')
    args = parser.parse_args()
    if len(args.install_targets) == 0 and not args.list and not args.check:
        parser.error('Please specify an install target')
    return args


def run():
    args = parse_args()
    dotfile_manager = DotfileInstaller(os.path.join(HOME, '.dotfiles'), args.dry_run)
    if args.list:
        dotfile_manager.list_targets()
    elif args.check:
        dotfile_manager.check()
    else:
        dotfile_manager.install(args.install_targets)


def main():
    try:
        run()
    except Exception as e:
        print(f"Error: {e}")


if __name__ == "__main__":
    main()
