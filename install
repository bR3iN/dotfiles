#!/usr/bin/env python

from __future__ import annotations
from argparse import ArgumentParser
from subprocess import run
from typing import Any, Callable, Dict, Iterable, List, Type, Union
from yaml.cyaml import CLoader
import os
import yaml


HOME = os.getenv('HOME')
assert HOME is not None


KeyWord = str
Path = str
Target = str


def load_config(dir: str, file_name='dotfiles.yaml') -> Dict:
    config: Dict
    path = os.path.join(dir, file_name)
    with open(path, 'r') as fh:
        config = yaml.load(fh.read(), Loader=CLoader)
    for key, value in config.items():
        if not isinstance(value, Dict):
            raise Exception(f"Config for target '{key}' is not a yaml mapping")
    return config


class Environment:
    dotfile_installer: DotfileInstaller
    current_target: Target
    def __init__(self, dotfile_installer, target):
        self.dotfile_installer = dotfile_installer
        self.current_target = target


class Action:
    job: Callable[[], Any]
    desc: str
    env: Environment

    def set_job(self, job: Callable[[], Any], desc: str):
        self.job = job
        self.desc = desc

    def set_env(self, env: Environment):
        self.env = env

    def get_description(self) -> str:
        return self.desc

    def execute(self) -> None:
        self.job()


class Plugin:
    def set_env(self, env: Environment):
        self.env = env

    def parse_config(self, _) -> List[Action]:
        raise Exception()


PluginConstructor = Type[Plugin]
PLUGINS: Dict[KeyWord, PluginConstructor] = {}


def register_plugin(key_word):
    def inner(cl):
        PLUGINS[key_word] = cl
        return cl
    return inner


def get_plugins():
    return PLUGINS


def validate(validator: Union[type, Callable], iter: Iterable):
    for el in iter:
        if isinstance(validator, type):
            assert isinstance(el, validator), f"Invalid item{el}"
        elif isinstance(validator, Callable):
            assert validator(el), f"Invalid item{el}"
        yield el


def islistof(ls: List, type: Type) -> bool:
    return any(map(lambda el: isinstance(el, type), ls))



###########
# Plugins #
###########


@register_plugin('hooks')
class HooksPlugin(Plugin):
    def parse_config(self, config) -> Iterable[Action]:
        return map(RunCmd, validate(str, config))


@register_plugin('links')
class LinksPlugin(Plugin):
    def parse_config(self, config) -> Iterable[Action]:
        is_valid = lambda i: isinstance(i[0], str) and isinstance(i[1], str)
        for src, dst in validate(is_valid, config.items()):
            yield CreateSymlink(src, dst)


@register_plugin('target')
class TargetPlugin(Plugin):
    def parse_config(self, config) -> Iterable[Action]:
        for target in validate(str, config):
            self.env.dotfile_installer.add(target)
        return
        yield  # type: ignore


@register_plugin('run')
class RunPlugin(Plugin):
    def parse_config(self, config) -> Iterable[Action]:
        is_valid = lambda cmd: isinstance(cmd, str) or islistof(cmd, str)
        return map(RunCmd, validate(is_valid, config))


@register_plugin('system-install')
class SystemInstallPlugin(Plugin):
    def parse_config(self, config) -> Iterable[Action]:
        for file in validate(str, config):
            if os.path.isfile(file):
                yield SystemInstallFile(file)
            elif os.path.isdir(file):
                yield SudoMakeInstall(file)
            else:
                raise Exception(f'{file} is neither file nor directory')


@register_plugin('install')
class InstallPlugin(Plugin):
    def parse_config(self, config) -> Iterable[Action]:
        dotfiles_dir = self.env.dotfile_installer.dotfiles_dir
        full_path = lambda file: os.path.join(dotfiles_dir, file)
        for path in map(full_path, validate(str, config)):
            if os.path.isfile(path):
                yield InstallFile(path)
            elif os.path.isdir(path):
                yield MakeInstall(path)
            else:
                raise Exception(f'{path} is neither file nor directory')



###########
# Actions #
###########


class PrintMsg(Action):
    def __init__(self, msg: str):
        self.set_job(lambda: None, msg)


class CreateSymlink(Action):
    def __init__(self, src: Path, dst: Path):
        desc = f"Creating symlink {src} -> {dst}"
        job = lambda: os.symlink(src, dst)
        self.set_job(job, desc)


class SudoMakeInstall(Action):
    def __init__(self, dir: str):
        desc = f'Running `sudo make install` inside {dir}'
        job = lambda: run(['sudo', 'make', 'install'], cwd=dir)
        self.set_job(job, desc)


class MakeInstall(Action):
    def __init__(self, dir: str):
        self.dir = dir
        desc = f'Running `make install` inside {self.dir}'
        job = lambda: run(['make', 'install'], cwd=self.dir)
        self.set_job(job, desc)


class InstallTarget(Action):
    def __init__(self, target: str):
        desc = f"Installing target '{target}'"
        job = lambda: self.env.dotfile_installer.add(target)
        self.set_job(job, desc)


class RunCmd(Action):
    def __init__(self, cmd: Union[str, List[str]]):
        s = f"{' '.join(cmd)}" if isinstance(cmd, list) else f'bash -c "{cmd}"'
        desc = f"Running '{s}'"
        cmd = cmd if isinstance(cmd, list) else ['bash', '-c', cmd]
        job = lambda: run(cmd, cwd=self.env.dotfile_installer.dotfiles_dir)
        self.set_job(job, desc)


class SystemInstallFile(RunCmd):
    def __init__(self, file: str):
        cmd = ['sudo', 'install', '-m755', '/usr/bin/', file]
        RunCmd.__init__(self, cmd)


class InstallFile(RunCmd):
    def __init__(self, file: str):
        cmd = ['install', '-m755', '-D', f'-t={HOME}/.local/bin', file]
        RunCmd.__init__(self, cmd)



class DotfileInstaller:
    dotfiles_dir: Path
    config_by_target: Dict[Target, Dict[KeyWord, Any]]
    dry_run: bool
    _installed: List[Target] = []
    _actions: List[Action] = []

    def __init__(self, dotfiles_dir: Path, dry_run=False):
        self.dotfiles_dir = dotfiles_dir
        self.config_by_target = load_config(dotfiles_dir)
        self.dry_run = dry_run

    def install(self, targets: List[Target]):
        for target in targets:
            self.add(target)
        self.execute_actions()
        self.print_success()

    def add(self, target: Target):
        if target in self._installed:
            return
        self._installed.append(target)
        self._actions.append(PrintMsg(f"Installing target {target}"))

        config = self.get_config(target)
        env = Environment(self, target)
        for key_word, plugin_config in config.items():
            plugin = self.get_plugin(key_word)
            plugin.set_env(env)
            for action in plugin.parse_config(plugin_config):
                action.set_env(env)
                self._actions.append(action)
        self._actions.append(PrintMsg(f"Finished installation of target {target}"))

    def execute_actions(self):
        for action in self._actions:
            print(action.get_description())
            if not self.dry_run:
                action.execute()

    def get_config(self, target: Target):
        try:
            return self.config_by_target[target]
        except KeyError:
            self.abort(f"No config found for target '{target}'")

    def get_plugin(self, key_word: KeyWord):
        plugins = get_plugins()
        try:
            return plugins[key_word]()
        except KeyError:
            self.abort(f"no plugin for keyword '{key_word}'")

    def list_targets(self):
        print('Available targets:')
        print('==================')
        for target in self.config_by_target.keys():
            print(target)

    def print_success(self):
        print()
        print("Successfully installed the following targets:")
        print("=============================================")
        for target in self._installed:
            print(target)

    def abort(self, msg):
        print(f"ERROR: {msg}")
        exit(1)



def parse_args():
    parser = ArgumentParser()
    parser.add_argument('install_targets', metavar='TARGET', type=str, nargs='*',
                        help='targets to install')
    parser.add_argument('--dry-run', '-d', action='store_true', default=False,
                        help='only print what would be done')
    parser.add_argument('--list', '-l', action='store_true',
                        help='list all install targets')
    args = parser.parse_args()
    if len(args.install_targets) == 0 and not args.list:
        parser.error('Please specify an install target')
    return args


def main():
    args = parse_args()
    dfm = DotfileInstaller(os.path.join(HOME, '.dotfiles'), args.dry_run)
    if args.list:
        dfm.list_targets()
        exit(0)
    dfm.install(args.install_targets)


if __name__ == "__main__":
    main()
